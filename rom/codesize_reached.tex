\subsubsection{\CSR{} constraints}

\CSR{} equals 0 while the \pc{} hasn't reached \CS{}, at which point it equals 1 until the end of the current \cfi{}. We remind the reader that \CSR{} is \textbf{CFI-incrementing}.
\begin{enumerate}
    \item \If $\pc_{i}=\cs_{i}-1$ \Then $\csr_{i}+\csr_{i+1}=1$  
\end{enumerate}

Before \CSR{} switches to one,
we are given with \limb{}
of $\llarge$ bytes,
therefore a $\llarge$ long \ct{}-loop.
After the \CSR{} switches to one, we want at least $\evmWordSize$ padded bytes after, in case the last opcode is a \inst{PUSH\_32}. 
\begin{enumerate}[resume]
    \item \If $\cfi_{i} \neq 0$ \et $\ct_{i}=0$ \Then:
    \begin{enumerate}
        \item \If $\CSR_{i}=0$ \Then $\ctMax_{i} = \llargeMO$
        \item \If $\CSR_{i}=1$ \Then $\ctMax_{i} = \evmWordSizeMO$
    \end{enumerate}
\end{enumerate}

