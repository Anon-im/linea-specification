\subsection{Interpretations of the term zk-EVM}
Several interpretations of what is a zk-EVM have been given. We aim here to describe more clearly these different definitions. 

\subsubsection{Solidity/Yul and EVM}
To begin with, we will make one first important distinction between Solidity/Yul compatibility and EVM-bytecode compatibility.
\begin{itemize}
    \item \textit{Solidity/Yul compatibility:} a special compiler/transpiler transforms the smart contract codes written in Solidity/Yul into a zk-EVM compatible bytecode/programming language. For now, this is the approach taken by zkSync  \cite{mediumZKEVM, zksynczkEVM}, that compiles Solidity into a zk-VM friendly bytecode using a LLVM compiler. Another project, currently developed by \textit{Nethermind}, (which initially aimed to build a EVM bytecode to Cairo transpiler \cite{nethermindEvmCairo}) has opted to convert Yul into Cairo \cite{nethermindSolCairo}. Working directly with Solidity/Yul has both advantages and disadvantages: 
    \begin{itemize}
        \item \textbf{Pros:} easier to adapt the generated bytecode to the technical constraints of the zk-EVMs - code execution, proof generation and verification are three very different processes that impose multiple architectural constraints that are non-trivial to overcome. 
        \item \textbf{Cons:} harder to prove that the behaviour of the EVM is well respected in this zk-system. Unpredictable edge cases may be left out, and new security holes may appear in this new compilation process. Besides, this approach completely discards the work that have been done on the solidity to EVM compiler, which has benefited from years of smart contract execution.
    \end{itemize}
    
    \item \textit{EVM bytecode compatibility:} rather than giving Solidity/Yul code as an input to the zk-EVM, one may provide \textit{EVM bytecode} directly. Quite often, the EVM bytecode is converted in a zk-EVM friendly bytecode/language, that would lead to a proof of execution generation. In addition to the approach presented in this note, other zk-EVM projects like Hermez's \cite{hermez} and Scroll tech's \cite{scroll} aim to provide \textit{full-EVM} compatibility. Working with the EVM bytecode directly also comes with Pros/Cons:
    \begin{itemize}
        \item \textbf{Pros:} easier to be compliant with the EVM behaviour as defined in the Ethereum yellow paper \cite{EthYellowpaperBerlin}, hence \textit{a priori} less prone to introduce new security issues - the description of the EVM is given at the bytecode level. Benefits from the work that have been done on the Solidity to EVM compiler. Easier to adapt to the new EIPs (defined at the Bytecode level). 
        \item \textbf{Cons:} \textit{a priori} harder to optimize and adapt to the zk-EVM - more rigidity on the instruction level. Requires the correct emulation of the totality of the EVM instruction set - which is both rich and complex.
    \end{itemize}
\end{itemize}


\subsubsection{Hash function compatibility}
Another important point in defining \textit{full-EVM} compatibility is the matter of \textit{hash functions}. Ethereum relies on SHA3 (Keccak), a notoriously SNARK unfriendly (almost prohibitively so) hash function.

For one, the EVM has a KECCAK instruction. Thus, to be \textit{fully-EVM} compatible, a zk-EVM must include this functionality.

The \textit{keccak} hash function is also used when computing the root hashes of an account's storage and the codehashes of contract bytecodes deployed on mainnet. Since smart contracts would have to be redeployed in our zk-rollup, we have have the freedom to replace keccak with a snark-friendly hash function such as \textit{MIMC} for the storage root hash and codehash computations. This significantly reduces the computational overhead. We also include a new \textit{MiMC} opcode to the set of available EVM instructions to let the choice of the hash function used within the smart contract execution. 

