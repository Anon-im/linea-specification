The present module performs a simple function: enact the lexicographic ordering constraints required by the \romMod{} module. The lexicographic ordering constraints in the \romMod{} module serve a single purpose: ensure code uniqueness i.e. that any \textbf{code fragment identifier} uniquely identifies a particular piece of bytecode. What we call code fragment identifier is the following data: address, deployment number and deployment status. Allowing for two different code fragments to have the same identifier would have deleterious consequences. Indeed, the \hubMod{} references instructions by means of (\emph{a}) a code fragment identifier and (\emph{b}) a program counter \pc{} (index of opcode in the bytecode.) If a given identifier were be associated with several code fragments a malicious prover could potentially choose, for a given \pc{} value, between several opcodes. A malicious attacker could furthermore perform illegal jumps i.e. jump to positions within the code that are precluded under jump destination analysis or on the contrary declare a legal jump illegal. Finally a malicious attacker could return a given code fragment when deploying a smart contract but commit to a different one in the state. Ensuring a one to one correspondence between code fragment identifiers and code fragments is thus of paramount importance.

The \romMod{} module enables this one to one correspondence by requiring code fragments to be listed according to a lexical order imposed on code fragment identifiers. Enforcing such constraints inside of the \romMod{} would be very expensive: (\emph{a}) the \romMod{} module is consistently several million rows deep (\emph{b}) verifying \emph{weak} lexicographic ordering constraints on $n$ columns (here $n=4$) require the introduction of $n+1$ boolean columns and $\llarge$ byte columns. In applications the number of referenced code fragments in a block on the order of a few hundred at most. The present module will therefore also only contain on the order of a few hundred (non padding) rows. Also since it enforces a \emph{strict} lexicographic ordering it only requires $n$ boolean columns. It therefore pays off to off-load this constraint system to a dedicated, much shallower module. 
