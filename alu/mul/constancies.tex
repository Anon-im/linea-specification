As always, we say that a column $\col{X}$ is \textbf{stamp-constant} if it satisfies
\[
	\If \mulStamp_{i - 1} = \mulStamp_{i}
	~ \Then
	\col{X}_{i - 1} = \col{X}_{i}.
\]
%Note that the \emph{stamp column isn't imported}.
We impose stamp-constancy conditions on the following columns\footnote{\ob{TODO: remove. Note: if $\mulStamp$ were imported from the stack (which was the original design), all other imported columns would automatically be stamp-constant. Not importing the stamp allows us to re-use previous computations to justify the current one. Surprisingly enough there is a lot of repetition in the \inst{EXP} instructions performed in a typical block.}}:
\begin{multicols}{4}
\begin{itemize}
	\item $\iArgOneHi$;
	\item $\iArgOneLo$;
	\item $\iArgTwoHi$;
	\item $\iArgTwoLo$;
	\item $\iResHi$;
	\item $\iResLo$;
	\item $\iInst$;
	\item[\vspace{\fill}]
\end{itemize}
\end{multicols}
\noindent Note that $\tinyExponent$, $\tinyBase$, $\oli$ and $\resVanishes$ are automatically stamp-constant seeing as they are directly derived from imported columns (see section~\ref{subsec (alu/exp): tiny base, tiny exponent, oli and result vanishes binary columns}.)

We also say that a column $\col{X}$ is \nBytes{}-constant if it satisfies
\[
	\Big(
	\iModStamp_{i} = \iModStamp_{i - 1}
	\et
	\nBytes_{i} = \nBytes_{i - 1}
	\Big)
	\implies
	\col{X}_{i} = \col{X}_{i - 1}.
\]
\ob{TODO: is \nBytes{}-constancy correctly defined ? \nBytes{} should be zero for \col{MUL} ? Do we even need it ? \dots{}}